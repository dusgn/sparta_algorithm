이론
어레이는 캡슐호텔, 원소 접근은 O(1), 중간에 삽입 삭제는 O(N), 새로 추가하려면 공간을 새로 할당 받아야 한다!
링크드리스트는 화물열차, 원소 접근은 O(N), 중간에 삽입 삭제는 O(1), 새로 추가하려면 뒤에 새로운 노드를 붙이기만 하면 된다!
Python 의 리스트 라는 자료구조는 어레이와 링크드리스트의 특성 둘 다 있으니, 상황에 따라 알맞게 사용하자!
클래스는 분류. 집합. 같은 속성과 기능을 가진 객체를 총칭하는 개념, 객체는 세상에 존재하는 유일무이한 사물
클래스는 생성자가 있어서 객체를 생성할 때마다 호출해주며, self 는 객체 자신을 가리키며, 클래스 내부에 함수를 정의해서 호출할수도 있다.
링크드 리스트를 구현하기 위해 Class Node 와 Class LinkedList 를 만든 뒤, LinkedList 의 self.data = [] 에다 하나씩 추가해준다!
링크드 리스트의 append 메소드는 어떻게 구현했지? 맨 마지막 노드까지 가서, next 에 새 노드를 만들어 붙여준다!
링크드 리스트의 print_all 메소드는 어떻게 구현했지? 각 노드를 따라가면서 값을 출력!
링크드 리스트의 get_node 메소드는 어떻게 구현했지? index만큼 이동해서 그 노드를 반환!
링크드 리스트의 add_node 메소드는 어떻게 구현했지? index만큼 이동해서 그 노드를 반환!
이 때, index - 1 처럼 -1 하는 코드가 있으면, 0의 경우에는 어떻게 될까? 를 항상 고민해주자.
이진 탐색은 반씩 후보지를 없애가면서 탐색하는 방법! 단, 항상 정렬되어 있어야 한다. 이분탐색의 시간 복잡도는 O(logN)!
이진 탐색을 구현하기 위해서는 3가지 개념이 필요하다. 최솟값, 최댓값, 시돗값! 이를 어떤 경우에 어떻게 변화시킬것인지 고민해보자.
재귀 함수는 자기 자신을 호출하는 함수. 단, 항상 탈출 조건이 있어야 한다!
재귀 함수로 문제를 해결하기 위해서는 문제를 좁혀가야 한다. “소주만병만주소” 에서 “주만병만주” 처럼! Factorial 에서는 F(n) = n * F(n - 1) 처럼!
결론
링크드 리스트와 어레이의 차이점? 링크드 리스트 구현하는 방법!
이진 탐색은 효율적인 탐색 방법! 그러나 항상 정렬되어 있을 때만 가능하다.
재귀 함수는 문제가 동일한 구조로 좁혀지는 경우에만 가능하다! 또한 항상 탈출 조건이 있어야만 한다.
실습
소수점 이하의 수를 모두 버리고 몫만 나타낼 수 있는 방법 //
문자열 자르는 방법 str[i:j]  혹은 str[i:] 혹은 str[:j]
배열 정렬하는 방법 array.sort()